<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>메인 페이지</title>
    <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.css" rel="stylesheet">

    <link rel="stylesheet" type="text/css" th:href="@{/css/calendar.css}">

    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chart.js DataLabels 플러그인 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
</head>
<body>
<div class="sidebar" th:insert="~{user/main/sidebar :: sidebar}"></div>

<div class="calendar">
    <div id="calendar-container">
        <div id="calendar"></div>
    </div>
</div>
<div class="overlay" id="modalOverlay" onclick="closeAllModals()"></div>

<!-- 식단 추천 유형 선택 모달 -->
<div id="mealTypeModal" class="modal">
    <p>선택하신 날짜에 맞추어<br>식단을 추천해드립니다.</p>
    <button onclick="selectMealType()">정보 기반 식단 추천</button>
    <button onclick="closeModal('mealTypeModal')">창 닫기</button>
</div>

<!-- 신체 정보 입력 모달 -->
<div id="bodyInfoModal" class="modal">
    <h3>신체 정보 입력</h3>
    <input type="number" id="inputHeight" placeholder="키(cm)" value="">
    <input type="number" id="inputWeight" placeholder="체중(kg)" value="">
    <h3>선호 식단 선택</h3>
    <div class="form-container">
        <label for="category1">1. 주식류</label>
        <select id="category1">
            <option value="밥류">밥류</option>
            <option value="빵 및 과자류">빵 및 과자류</option>
            <option value="면 및 만두류">면 및 만두류</option>
            <option value="죽 및 스프류">죽 및 스프류</option>
            <option value="국 및 탕류">국 및 탕류</option>
            <option value="찌개 및 전골류">찌개 및 전골류</option>
        </select>
    </div>

    <div class="form-container">
        <label for="category2">2. 부식류</label>
        <select id="category2">
            <option value="찜류">찜류</option>
            <option value="구이류">구이류</option>
            <option value="전·적 및 부침류">전·적 및 부침류</option>
            <option value="볶음류">볶음류</option>
            <option value="조림류">조림류</option>
            <option value="튀김류">튀김류</option>
        </select>
    </div>

    <div class="form-container">
        <label for="category3">3. 반찬류</label>
        <select id="category3">
            <option value="나물·숙채류">나물·숙채류</option>
            <option value="생채·무침류">생채·무침류</option>
            <option value="김치류">김치류</option>
            <option value="젓갈류">젓갈류</option>
            <option value="장아찌·절임류">장아찌·절임류</option>
            <option value="선호 하지 않음">선호하지 않음</option>
        </select>
    </div>

    <div class="form-container">
        <label for="category4">4. 기타</label>
        <select id="category4">
            <option value="유제품류 및 빙과류">유제품류 및 빙과류</option>
            <option value="과일류">과일류</option>
            <option value="두류, 견과 및 종실류">두류, 견과 및 종실류</option>
            <option value="선호 하지 않음">선호하지 않음</option>
        </select>
    </div>

    <button onclick="submitBodyInfo()">식단 추천 받기</button>
    <button onclick="closeModal('bodyInfoModal')">취소</button>
</div>

<!-- 식단 확인(설명) 모달 -->
<div id="mealDescriptionModal" class="modal">
    <h3>추천 식단 세부 정보</h3>
    <div id="recommendedMeal"></div>
    <button onclick="closeModal('mealDescriptionModal')">닫기</button>
</div>

<!-- Thymeleaf를 사용하여 서버에서 전달된 데이터를 JavaScript 변수로 주입 -->
<script th:inline="javascript">
    let isLoggedIn = [[${isLoggedIn ? true : false}]];
    console.log('isLoggedIn:', isLoggedIn);
    let user = {
        userId: '[[${user?.userId ?: ""}]]',
        gender: '[[${user?.gender ?: ""}]]',
        birthday: '[[${user?.birthday != null ? #temporals.format(user.birthday, "yyyy-MM-dd") : "2000-01-01"}]]',
        height: [[${user?.height != null ? user.height : 0}]],
    weight: [[${user?.weight != null ? user.weight : 0}]]
    };

    let saveFoods = [];
    let currentDeleteSfSeq = null;
</script>

<script>
    let calendar;
    let selectedDate;
    let currentFood = null;
    let macroChartInstance = null;

    const mealColors = {
        'breakfast': '#f6816d',
        'lunch': '#d6c968',
        'dinner': '#7bd17b'
    };

    function getMealOrder(mealType) {
        switch(mealType) {
            case 'breakfast': return 1;
            case 'lunch':     return 2;
            case 'dinner':    return 3;
            default:          return 999;
        }
    }

    document.addEventListener('DOMContentLoaded', async function () {
        const calendarEl = document.getElementById('calendar');

        calendar = new FullCalendar.Calendar(calendarEl, {
            initialView: 'dayGridMonth',
            locale: 'ko',
            eventOrder: (a, b) => {
                const orderA = a.extendedProps.order || 999;
                const orderB = b.extendedProps.order || 999;
                return orderA - orderB;
            },
            events: Array.isArray(saveFoods) ? saveFoods.map(sf => ({
                id: String(sf.sfSeq),
                title: sf.mealType,
                start: new Date(sf.saveDate).toISOString(),
                color: mealColors[sf.mealType] || '#FFA500',
                extendedProps: {
                    order: getMealOrder(sf.mealType)
                }
            })) : [],
            eventDisplay: 'block',
            dayMaxEvents: true,
            dateClick: handleDateClick,
            eventClick: handleEventClick
        });

        // 서버에서 저장된 식단 로드
        try {
            const response = await axios.get('/api/users/foodInfo', {
                withCredentials: true
            });
            if (response.data && Array.isArray(response.data)) {
                saveFoods = response.data;
                saveFoods.forEach(sf => {
                    calendar.addEvent({
                        id: String(sf.sfSeq),
                        title: sf.mealType,
                        start: new Date(sf.saveDate).toISOString(),
                        color: mealColors[sf.mealType] || '#FFA500',
                        extendedProps: {
                            order: getMealOrder(sf.mealType)
                        }
                    });
                });
            } else {
                console.warn('SaveFoods 데이터가 비어있습니다.');
            }
        } catch (error) {
            console.error('SaveFoods 로드 실패:', error);
        }

        calendar.render();
    });

    function handleDateClick(info) {
        selectedDate = info.dateStr;

        const today = new Date();
        const selectedDateObj = new Date(info.date.getFullYear(), info.date.getMonth(), info.date.getDate());
        const todayObj = new Date(today.getFullYear(), today.getMonth(), today.getDate());

        if (selectedDateObj < todayObj) {
            alert("과거 날짜에는 새로운 식단을 추가할 수 없습니다.");
        } else {
            // 이미 저장된 식단이 있는 날짜인지 확인
            const existingFood = saveFoods.find(food =>
                new Date(food.saveDate).toISOString().split('T')[0] === selectedDate
            );

            if (existingFood) {
                // 저장된 식단이 있는 경우: 세부 정보 보기
                alert("해당 날짜에는 이미 저장된 식단이 있습니다.");
                displayDetailedInfo(existingFood);
            } else {
                // 저장된 식단이 없는 경우: 로그인 상태에 따라 추천 모달 표시
                if (!isLoggedIn) {
                    const modalContent = `
                    <div style="text-align: center;">
                        <p>Healthy Table 만의<br>식단 추천을 받고 싶으신가요?</p>
                        <button onclick="location.href='/login'" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; cursor: pointer;">
                            로그인
                        </button>
                    </div>
                `;
                    showModalWithContent(modalContent);
                } else {
                    showModal('mealTypeModal');
                }
            }
        }
    }


    function handleEventClick(info) {
        const selectedFood = saveFoods.find(food => String(food.sfSeq) === String(info.event.id));
        if (selectedFood) {
            displayDetailedInfo(selectedFood);
        } else {
            console.error("해당 식단을 찾을 수 없습니다: sfSeq =", info.event.id);
            alert("해당 식단을 찾을 수 없습니다.");
        }
    }

    async function deleteMeal(sfSeq) {
        try {
            const response = await axios.delete(`/api/users/foodInfo/${sfSeq}`);
            if (response.status === 200) {
                const event = calendar.getEventById(String(sfSeq));
                if (event) {
                    event.remove();
                    saveFoods = saveFoods.filter(food => String(food.sfSeq) !== String(sfSeq));
                    alert("식단이 삭제되었습니다.");
                    closeModal('mealDescriptionModal');
                } else {
                    console.error("캘린더에서 이벤트를 찾을 수 없습니다.");
                    alert("서버에서 식단을 삭제했지만 캘린더 업데이트에 실패했습니다.");
                }
            } else {
                console.error("식단 삭제 실패:", response.status);
                alert("식단 삭제에 실패했습니다.");
            }
        } catch (error) {
            console.error("식단 삭제 중 오류 발생:", error);
            alert("식단 삭제 중 오류가 발생했습니다.");
        }
    }

    function confirmDelete() {
        if (currentDeleteSfSeq !== null) {
            if (confirm("정말로 이 식단을 삭제하시겠습니까?")) {
                deleteMeal(currentDeleteSfSeq);
            }
            currentDeleteSfSeq = null;
        }
    }

    // --------------------------------------------
    // 식단 세부 정보 + 파이차트 표시 준비
    // --------------------------------------------
    function displayDetailedInfo(food) {
        currentFood = food;
        const mealDiv = document.getElementById('recommendedMeal');

        // **chartContainer를 "flex" 구조로 잡고,
        //  왼쪽: canvas, 오른쪽: 설명 div(#chartExplanation)**
        mealDiv.innerHTML = `
            <p>저장 날짜: ${new Date(food.saveDate).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}</p>
            <p>식단 유형: ${food.mealType}</p>
            <table>
                <thead>
                    <tr>
                        <th>메뉴 이름</th>
                        <th>칼로리 (kcal)</th>
                        <th>단백질 (g)</th>
                        <th>탄수화물 (g)</th>
                        <th>지방 (g)</th>
                    </tr>
                </thead>
                <tbody>
                    ${food.menus.map(menu => `
                        <tr>
                            <td>${menu.name}</td>
                            <td>${menu.calories}</td>
                            <td>${menu.protein}</td>
                            <td>${menu.carbohydrates}</td>
                            <td>${menu.fat}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
            <button onclick="prepareDelete('${food.sfSeq}')">삭제</button>

            <!-- 파이차트 보기 버튼 -->
            <button onclick="showPieChart()">파이차트 보기</button>

            <!-- **flex 레이아웃** -->
            <div id="chartContainer" style="margin-top: 20px; display: none;">
                <div style="display: flex; gap: 30px;">
                    <!-- 왼쪽: 파이차트 -->
                    <div style="flex: 1;">
                        <canvas id="macroPieChart" width="300" height="300"></canvas>
                    </div>
                    <!-- 오른쪽: 파이차트 설명 -->
                    <div style="flex: 1;" id="chartExplanation">
                        <!-- showPieChart() 내부에서 동적으로 내용을 채움 -->
                    </div>
                </div>
            </div>
        `;
        showModal('mealDescriptionModal');
    }

    function prepareDelete(sfSeq) {
        currentDeleteSfSeq = sfSeq;
        confirmDelete();
    }

    async function submitBodyInfo() {
        const inputHeight = parseFloat(document.getElementById('inputHeight').value);
        const inputWeight = parseFloat(document.getElementById('inputWeight').value);

        if (isNaN(inputHeight) || isNaN(inputWeight) || inputHeight <= 0 || inputWeight <= 0) {
            alert("올바른 신체 정보를 입력해주세요.");
            return;
        }

        const bmr = calculateBMR({
            height: inputHeight,
            weight: inputWeight,
            birthday: user.birthday,
            gender: user.gender
        });
        let adjustedBmr = bmr;

        const bmi = calculateBMI({ height: inputHeight, weight: inputWeight });
        if (bmi > 25) {
            adjustedBmr = bmr * 0.95;
        } else if (bmi > 23) {
            adjustedBmr = bmr;
        } else if (bmi < 18.5) {
            adjustedBmr = bmr * 1.05;
        }

        const requestData = {
            height: inputHeight,
            weight: inputWeight,
            bmr: adjustedBmr,
            category1: document.getElementById('category1').value,
            category2: document.getElementById('category2').value,
            category3: document.getElementById('category3').value,
            category4: document.getElementById('category4').value,
            selectedDate: new Date(selectedDate).toISOString().split('T')[0],
        };

        try {
            const response = await axios.post('/api/users/foodInfo', requestData, {
                headers: {
                    'Content-Type': 'application/json'
                },
                withCredentials: true
            });

            if (response.data && Array.isArray(response.data.savedFoods)) {
                response.data.savedFoods.forEach(savedFood => {
                    calendar.addEvent({
                        id: String(savedFood.sfSeq),
                        title: savedFood.mealType,
                        start: new Date(savedFood.saveDate).toISOString(),
                        color: mealColors[savedFood.mealType] || '#FFA500',
                        extendedProps: {
                            order: getMealOrder(savedFood.mealType)
                        }
                    });
                    saveFoods.push(savedFood);
                });
                closeModal('bodyInfoModal');
                alert("식단이 추천되었습니다.");
            } else {
                alert("추천 식단을 가져오는 데 실패했습니다.");
            }
        } catch (error) {
            console.error('식단 추천 실패:', error);
            alert("식단 추천에 실패했습니다.");
        }
    }

    // --------------------------------------------
    // 파이차트 표시 함수 (총 칼로리 + 가로 정렬 설명)
    // --------------------------------------------
    function showPieChart() {
        if (macroChartInstance) {
            macroChartInstance.destroy();
            macroChartInstance = null;
        }

        document.getElementById('chartContainer').style.display = 'block';
        if (!currentFood) return;

        // (1) 총단백질(g), 총탄수화물(g), 총지방(g) 계산
        let totalProtein = 0, totalCarbs = 0, totalFat = 0;
        currentFood.menus.forEach(menu => {
            totalProtein += (menu.protein || 0);
            totalCarbs   += (menu.carbohydrates || 0);
            totalFat     += (menu.fat || 0);
        });

        // g당 kcal: 단백질4, 탄수화물4, 지방9
        const proteinCals = totalProtein * 4;
        const carbsCals   = totalCarbs * 4;
        const fatCals     = totalFat * 9;
        const totalCals   = proteinCals + carbsCals + fatCals;

        if (totalCals === 0) {
            alert("영양소 정보가 없어 파이차트를 생성할 수 없습니다.");
            return;
        }

        // 퍼센티지 계산
        const proteinPct = (proteinCals / totalCals) * 100;
        const carbsPct   = (carbsCals   / totalCals) * 100;
        const fatPct     = (fatCals     / totalCals) * 100;

        // (2) 파이차트 생성
        const ctx = document.getElementById('macroPieChart').getContext('2d');
        macroChartInstance = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: [
                    `단백질 (${totalProtein.toFixed(1)}g)`,
                    `탄수화물 (${totalCarbs.toFixed(1)}g)`,
                    `지방 (${totalFat.toFixed(1)}g)`
                ],
                datasets: [{
                    data: [
                        proteinPct.toFixed(1),
                        carbsPct.toFixed(1),
                        fatPct.toFixed(1)
                    ],
                    backgroundColor: ['#36A2EB', '#FFCD56', '#FF6384']
                }]
            },
            plugins: [ChartDataLabels],
            options: {
                responsive: false,
                plugins: {
                    datalabels: {
                        color: '#fff',
                        anchor: 'center',
                        align: 'center',
                        formatter: (value) => {
                            return value + '%';
                        },
                        font: {
                            size: 14,
                            weight: 'bold'
                        }
                    },
                    legend: {
                        display: true,
                        labels: {
                            font: { size: 13 }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const val   = context.formattedValue || '';
                                return `${label} - ${val}%`;
                            }
                        }
                    }
                }
            }
        });

        // (3) 오른쪽 영역(#chartExplanation)에 상세 정보 출력
        const explainDiv = document.getElementById('chartExplanation');
        explainDiv.innerHTML = `
            <h4>영양소 요약</h4>
            <ul>
                <li>단백질: ${totalProtein.toFixed(1)}g (${proteinPct.toFixed(1)}%)</li>
                <li>탄수화물: ${totalCarbs.toFixed(1)}g (${carbsPct.toFixed(1)}%)</li>
                <li>지방: ${totalFat.toFixed(1)}g (${fatPct.toFixed(1)}%)</li>
            </ul>
            <p><strong>총 칼로리: ${totalCals.toFixed(0)} kcal</strong></p>
        `;
    }

    // BMI/BMR 계산
    function calculateBMI({ height, weight }) {
        return weight / Math.pow(height / 100, 2);
    }
    function calculateBMR({ height, weight, birthday, gender }) {
        const age = calculateAge(birthday);
        return gender === "MALE"
            ? 66.47 + (13.75 * weight) + (5 * height) - (6.76 * age) + 900
            : 655.1 + (9.56 * weight) + (1.85 * height) - (4.68 * age) + 700;
    }
    function calculateAge(birthdayStr) {
        if (!birthdayStr) {
            birthdayStr = '2000-01-01';
        }
        const birthday = new Date(birthdayStr);
        const today = new Date();
        let age = today.getFullYear() - birthday.getFullYear();
        const m = today.getMonth() - birthday.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthday.getDate())) {
            age--;
        }
        return age;
    }

    function showModal(modalId) {
        document.getElementById(modalId).classList.add('active');
        document.getElementById('modalOverlay').classList.add('active');
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
        document.getElementById('modalOverlay').classList.remove('active');

        // 모달을 닫을 때 차트 초기화 (재오픈 시 새로 생성되도록)
        if (modalId === 'mealDescriptionModal' && macroChartInstance) {
            macroChartInstance.destroy();
            macroChartInstance = null;
            document.getElementById('chartContainer').style.display = 'none';
        }
    }

    function closeAllModals() {
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => modal.classList.remove('active'));
        document.getElementById('modalOverlay').classList.remove('active');

        if (macroChartInstance) {
            macroChartInstance.destroy();
            macroChartInstance = null;
            document.getElementById('chartContainer').style.display = 'none';
        }
    }

    function selectMealType() {
        closeModal('mealTypeModal');
        showModal('bodyInfoModal');
    }

    function showModalWithContent(content) {
        const existingModal = document.getElementById('customModal');
        if (existingModal) {
            existingModal.remove();
        }
        const modal = document.createElement('div');
        modal.id = 'customModal';
        modal.className = 'modal active';

        modal.innerHTML = `
            <div class="modal-content">
                ${content}
                <button class="close-button" onclick="closeCustomModal()">닫기</button>
            </div>
        `;
        document.body.appendChild(modal);
        document.getElementById('modalOverlay').classList.add('active');
    }

    function closeCustomModal() {
        const modal = document.getElementById('customModal');
        if (modal) {
            modal.remove();
        }
        document.getElementById('modalOverlay').classList.remove('active');
    }
</script>
</body>
</html>
